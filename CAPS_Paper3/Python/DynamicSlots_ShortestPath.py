# -*- coding: utf-8 -*-
"""
Created on April '20'

@author: Sohom Chatterjee
"""
#%% 1. Import Libraries
import matplotlib.pyplot as plt
import seaborn as sns
import random
from sympy import bell
from tqdm import tqdm
import numpy as np 
# import scipy.stats as stats
# import sys
import pandas as pd
import gurobipy as gp
from gurobipy import *
from gurobipy import tupledict
# import time
import cmath
import math
#%% 2. Function Definitions
def weight(Node_1,Node_2):
    # print(Node_1,Node_2)
    sum=0
    for i in range(Node_1,Node_2):
        term=lambda_vec[i]*(Node_2-i)
        # if Node_1==25:
            # print(i)
        sum+=term/(1-term)
    # print(sum)    
    return sum


def feas_limit(lv):
    
    """
    Parameters
    ----------
    lambda_vec : list

    Returns
    -------
    final_vec : list
        
    This function takes as input the arrival vector and returns final_vec. 
    Each item in final_vec represents the node till which we construct edges for that index in the graph.
    eg., final_vec[i]=j represents that in the graph, each node from i to j-1 will have a node to j.
    """
    slots = len(lv)
    slot_vec=[i+math.floor(1/lv[i]) for i in range(slots)]
    low_lim=0
    final_vec=[]
    while len(final_vec)<slots:
        mn=min(slot_vec[low_lim:])
        argmin=(slot_vec[low_lim:]).index(mn)+len(slot_vec[:low_lim])
        hm=argmin-low_lim+1
        final_vec=final_vec+[mn]*hm  
        low_lim=low_lim+hm
    return final_vec[0:slots]


def Bellman(cost,B):   
    d=[[None for i in range(pop+1)] for i in range(B+1)]
    d[0]=[float("inf") for i in range(pop+1)]
    d[0][0]=0.0
    pathNode=[[None for i in range(pop+1)] for i in range(B+1)]
    for k in range(B):
        for i in range(pop+1):
            tempMin=float("inf")
            tempIndex=-1.0
            for j in range(i):
                if d[k][j]+cost[j][i]<tempMin:
                    tempMin=d[k][j]+cost[j][i]
                    tempIndex=j
            if tempMin<d[k][i]:
                d[k+1][i]=tempMin
                pathNode[k+1][i]=tempIndex
            else:
                d[k+1][i]=d[k][i]
                pathNode[k+1][i]=pathNode[k][i]
    
    path=[]
    node=pop
    # path.append(node)
    k=B
    while node>0:
        node=pathNode[k][node]
        path.append(node)
        k=k-1
        
    node_list=path
    of=0
    of+=cost[node_list[0]][slots]
    for ele in range(0,len(node_list)-1):
        of+=cost[node_list[ele+1]][node_list[ele]]
    return node_list,of

def calc_meas(cost,node_list):
    of=0
    of+=cost[node_list[0]][slots]
    for ele in range(0,len(node_list)-1):
        of+=cost[node_list[ele+1]][node_list[ele]]
    return of
#%% 3. LAMBDA_VECTOR
# lambda_vec=[
#     0.9,0.9,0.9,0.9,0.9,0.9,0.9,0.9,0.9,0.9,0.9,0.9,0.9,0.9,0.9,0.9,0.9,0.9,0.9,0.9
# ]
#Regular ArrivalRate
# lambda_vec=[3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,3.26025,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,4.181625,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.54375,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.217725,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.43035,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.161025,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,3.302775,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.877525,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.735775,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,2.35305,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.978075,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.269325,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.6237,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.212625,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.014175,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525,0.042525]
# lambda_vec = [i / 36 for i in lambda_vec]

#Crisis ArrivalRate
weekly_lam=[0.0078125,0.0129774305555556,0.0142361111111111,0.0173177083333333,0.0197048611111111,0.0225694444444444,0.0250868055555556,0.0246527777777778,0.0262586805555556,0.0273003472222222,0.0264756944444444,0.0238715277777778,0.0202690972222222,0.0180555555555556,0.0168836805555556,0.0133246527777778,0.00677083333333333,0.000477430555555556
]
      
lambda_vec=[]
for i in weekly_lam:
    lambda_vec=lambda_vec+[i]*40



slots=len(lambda_vec)
# print(slots)
pop=slots
feas_vec=feas_limit(lambda_vec)
# feas_vec=[i+2 for i in range(slots)]

wt=[[100000000 for i in range(slots+1)]for i in range(slots)]
for i in range(0,slots):
   for j in range(i+1,slots+1):
       if j>=feas_vec[i]:
           break
       else:
           # print(i,j)
           wt[i][j]=weight(i,j)


#%% 4. Simulation

a=Bellman(wt,29)